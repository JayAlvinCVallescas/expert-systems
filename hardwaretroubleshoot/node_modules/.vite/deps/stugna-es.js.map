{
  "version": 3,
  "sources": ["../../stugna-es/fact.js", "../../stugna-es/errors-rule.js", "../../stugna-es/rule.js", "../../stugna-es/errors-fact.js", "../../stugna-es/errors-stugna-es.js", "../../stugna-es/stugna-es.js"],
  "sourcesContent": ["'use strict';\n\n/**\n *\n */\nclass Fact {\n\n  /**\n   *\n   * @param name {string}\n   * @param value {boolean|number|string}\n   * @param description {string}\n   */\n  constructor(name, value, description) {\n    // name\n    this.name = name;\n\n    // value\n    if (typeof value === 'string' && value.length > 1) {\n      value = value.replace(/'/g, '');\n      if (value === 'TRUE') {\n        value = true;\n      }\n      if (value === 'FALSE') {\n        value = false;\n      }\n    }\n    this.value = value;\n\n    // etc\n    this.history = [description];\n    this.changed = false; // false - init fact value; true - fact value changed by rules\n  }\n}\n\nmodule.exports = {Fact}", "'use strict';\n\nconst ERROR_RULE_CONDITION_EMPTY = 'Rule condition cannot be empty';\n\nconst ERROR_RULE_FACT_NAME_EMPTY = 'Fact name cannot be empty';\nconst ERROR_RULE_FACT_NAME_HAS_SPACES = 'Fact name cannot contain spaces';\nconst ERROR_RULE_FACT_VALUE_EMPTY = 'Fact value cannot be empty';\n\nconst ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES = 'factValueElse cannot contain spaces';\nconst ERROR_RULE_ELSE_FACT_NAME_ABSENT = 'If you use factValueElse you have to fill factNameElse';\nconst ERROR_RULE_ELSE_FACT_VALUE_ABSENT = 'If you use factNameElse you have to fill factValueElse';\n\nconst ERROR_RULE_STRING_NO_QUOTE = \"there is no ' to close string value\";\nconst ERROR_RULE_PARENTHESES_1 = 'parentheses mismatched (1)';\nconst ERROR_RULE_PARENTHESES_2 = 'parentheses mismatched (2)';\n\nmodule.exports = {\n  ERROR_RULE_CONDITION_EMPTY,\n\n  ERROR_RULE_FACT_NAME_EMPTY,\n  ERROR_RULE_FACT_NAME_HAS_SPACES,\n  ERROR_RULE_FACT_VALUE_EMPTY,\n\n  ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES,\n  ERROR_RULE_ELSE_FACT_NAME_ABSENT,\n  ERROR_RULE_ELSE_FACT_VALUE_ABSENT,\n\n  ERROR_RULE_STRING_NO_QUOTE,\n  ERROR_RULE_PARENTHESES_1,\n  ERROR_RULE_PARENTHESES_2,\n}\n", "'use strict';\n\nconst {\n  ERROR_RULE_CONDITION_EMPTY,\n\n  ERROR_RULE_FACT_NAME_EMPTY,\n  ERROR_RULE_FACT_NAME_HAS_SPACES,\n  ERROR_RULE_FACT_VALUE_EMPTY,\n\n  ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES,\n  ERROR_RULE_ELSE_FACT_NAME_ABSENT,\n  ERROR_RULE_ELSE_FACT_VALUE_ABSENT,\n\n  ERROR_RULE_STRING_NO_QUOTE,\n  ERROR_RULE_PARENTHESES_1,\n  ERROR_RULE_PARENTHESES_2\n} = require('./errors-rule');\n\nconst OPERATORS = {\n  '(' :   {priority: 4, arg_count: 2, left_associativity: 1, calc: null },\n  ')' :   {priority: 4, arg_count: 2, left_associativity: 1, calc: null },\n\n  '+' :   {priority: 3, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value + b.value } },\n  '-' :   {priority: 3, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value - b.value } },\n  '*' :   {priority: 3, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value * b.value } },\n  '/' :   {priority: 3, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value / b.value } },\n\n  '<' :   {priority: 2, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value <   b.value } },\n  '<=' :  {priority: 2, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value <=  b.value } },\n  '>' :   {priority: 2, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value >   b.value } },\n  '>=' :  {priority: 2, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value >=  b.value } },\n  '=' :   {priority: 2, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value === b.value } },\n  '<>' :  {priority: 2, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value !== b.value } },\n  'LIKE': {priority: 2, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value.toString().indexOf(b.value.toString()) !== -1 } },\n\n  'AND' : {priority: 1, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value && b.value } },\n  'OR'  : {priority: 1, arg_count: 2, left_associativity: 1, calc: function (a, b){ return a.value || b.value } },\n  'NOT' : {priority: 1, arg_count: 1, left_associativity: 0, calc: function (a){ return !a.value } }\n}\n\nconst CHAR_CODE_0 = 48;\nconst CHAR_CODE_9 = 57;\n\nconst TOKEN_UNKNOWN     = 0;\nconst TOKEN_BOOLEAN     = 1;\nconst TOKEN_NUMBER      = 2;\nconst TOKEN_STRING      = 3;\nconst TOKEN_VARIABLE    = 4;\nconst TOKEN_OPERATOR    = 5;\nconst TOKEN_PARENTHESIS = 6;\n// const TOKEN_UNKNOWN     = 'UNKNOWN';\n// const TOKEN_BOOLEAN     = 'BOOLEAN';\n// const TOKEN_NUMBER      = 'NUMBER';\n// const TOKEN_STRING      = 'STRING';\n// const TOKEN_VARIABLE    = 'VARIABLE';\n// const TOKEN_OPERATOR    = 'OPERATOR';\n// const TOKEN_PARENTHESIS = 'PARENTHESIS';\n\nconst regexpWhiteSpaces = new RegExp('\\\\s+', 'g');\n\n/**\n *\n */\nclass Rule {\n  /**\n   * @param condition {string}\n   * @param factName {string}\n   * @param factValue {number|string|null}\n   * @param priority {number}\n   * @param description {string}\n   * @param factNameElse {string|undefined}\n   * @param factValueElse {number|string|undefined}\n   * @param final {number|undefined}\n   * @param precondition {string|null|undefined}\n   * @param missing {number|string|null}\n   */\n  constructor(condition,\n              factName, factValue,\n              priority, description,\n              factNameElse, factValueElse,\n              final, precondition, missing) {\n    // init\n    this.condition = condition;       // human raw readable text of rule\n    this.precondition = precondition !== null ? precondition : undefined; // human raw readable text of precondition\n    this.fact = factName;\n    this.value = factValue;\n    this.factElse = factNameElse !== null ? factNameElse : undefined;\n    this.valueElse = factValueElse !== null ? factValueElse : undefined;\n    if (priority && priority > 0)\n      this.priority = priority;\n    else\n      this.priority = 1;\n    if (description)\n      this.description = description; // detailed rule description\n    else\n      this.description = Rule.createDescription(condition, factName, factValue, factNameElse, factValueElse);\n    if (final && final >= 1 && final <= 3)\n      this.final = final;\n    else\n      this.final = undefined;\n    this.missing = missing !== null ? missing : undefined;\n    this.error = null;                // rule error\n\n    this.precalc = [];                // reverse polish notation for rule precondition calculation\n    this.prevariables = [];           // variables list from precondition\n    this.calc = [];                   // reverse polish notation for rule condition calculation\n    this.variables = [];              // variables list from condition\n    let tokens = [];                  // parsed rule tokens\n\n    // precondition\n    if (this.precondition !== undefined) {\n      [tokens, this.error] = this._tokenize(this.precondition, 'Precondition');\n      if (this.error === null) {\n        [this.precalc, this.error] = this._parse(tokens, 'Precondition');\n        if (this.error === null) {\n          this.prevariables = this._collectVariables(this.precalc);\n        }\n      }\n    }\n\n    // condition\n    if (this.error === null) {\n      [tokens, this.error] = this._tokenize(condition, 'Condition');\n      if (this.error === null) {\n        [this.calc, this.error] = this._parse(tokens, 'Condition');\n        if (this.error === null) {\n          this.variables = this._collectVariables(this.calc);\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param condition\n   * @param factName\n   * @param factValue\n   * @param factElse\n   * @param factNameElse\n   * @param factValueElse\n   * @returns {string}\n   */\n  static createDescription(condition, factName, factValue, factNameElse, factValueElse) {\n    let postfix = '';\n    if (factNameElse) {\n      postfix = ` / {${factNameElse}: ${factValueElse}}`;\n    }\n    return `${condition} / {${factName}: ${factValue}}${postfix}`;\n  }\n\n  /**\n   * @param name {string}\n   */\n  _operatorHasLeftAssociativity(name) {\n    let operator = OPERATORS[name];\n    if (!operator) {\n      return null;\n    }\n    return operator.left_associativity;\n  }\n\n  /**\n   * @param name {string}\n   */\n  _operatorPriority(name) {\n    let operator = OPERATORS[name];\n    if (!operator) {\n      return null;\n    }\n    return operator.priority;\n  }\n\n  _mayBeNumber(str) {\n    if (!str) {\n      return false;\n    }\n    let code = str.charCodeAt(0);\n    return code >= CHAR_CODE_0 && code <= CHAR_CODE_9;\n  }\n\n  _mayBeFloat(str) {\n    if (!str) {\n      return false;\n    }\n    return str.indexOf('.') !== -1;\n  }\n\n  /**\n   * Validate rule inputs\n   */\n  static validate (condition, fact, value, factElse, valueElse) {\n    if (!condition) {\n      return ERROR_RULE_CONDITION_EMPTY;\n    }\n\n    if (!fact) {\n      return ERROR_RULE_FACT_NAME_EMPTY;\n    }\n    if(regexpWhiteSpaces.test(fact)) {\n      return ERROR_RULE_FACT_NAME_HAS_SPACES;\n    }\n    if (value === null || value === undefined) {\n      return ERROR_RULE_FACT_VALUE_EMPTY;\n    }\n\n    if (factElse || valueElse) {\n      if (factElse && (valueElse === null || valueElse === undefined)) {\n        return ERROR_RULE_ELSE_FACT_VALUE_ABSENT;\n      }\n      if (valueElse && (factElse === null || factElse === undefined)) {\n        return ERROR_RULE_ELSE_FACT_NAME_ABSENT;\n      }\n      if(regexpWhiteSpaces.test(factElse)) {\n        return ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasElse() {\n    return this.factElse !== null && this.factElse !== undefined;\n  }\n\n  /**\n   * @param tokens {Object[]}\n   */\n  checkUnaryMinus(tokens) {\n    let result = [];\n    let tokenPrev = null;\n    for (let i=0; i<tokens.length; i++) {\n      let tokenCurrent = tokens[i];\n      let tokenNext = null;\n      let tokenNextIsNumber = false;\n      if (i < tokens.length-1) {\n        tokenNext = tokens[i+1];\n        tokenNextIsNumber = (tokenNext.type === TOKEN_NUMBER);\n      }\n      if (tokenCurrent.type === TOKEN_OPERATOR && tokenCurrent.value === '-' && tokenNextIsNumber) {\n        let isUnaryMinus = false;\n        if (tokenPrev === null) {\n          isUnaryMinus = true;\n        } else {\n          if (tokenPrev.type !== TOKEN_NUMBER) {\n            isUnaryMinus = true;\n          }\n        }\n        if (isUnaryMinus) {\n          // it`s unary minus\n          tokenNext.value *= -1;\n        } else {\n          // it`s usual minus\n          result.push(tokenCurrent);\n        }\n      } else {\n        // it`s not minus\n        result.push(tokenCurrent);\n      }\n      tokenPrev = tokenCurrent;\n    }\n    return result;\n  }\n\n  /**\n   * Lexical analysis\n   * @param raw {string}\n   * @param errorSource {string}\n   * @returns {*[][]}\n   * @private\n   */\n  _tokenize(raw, errorSource) {\n    let tokens = []\n    let error = null;\n\n    // preprocess\n    raw = raw.replace(/<>/g, '###42@@@'); // protect <> operator from inflation to < >\n    raw = raw.replace(/>=/g, '###43@@@');\n    raw = raw.replace(/<=/g, '###44@@@');\n\n    // inflate\n    let operators = Object.keys(OPERATORS);\n    for(let word of operators) {\n      let shift = 0;\n      let pos = raw.indexOf(word, shift);\n      while (pos !== -1) {\n        let head = raw.substring(0, pos);\n        pos += word.length;\n        let tail = raw.substring(pos);\n        raw = `${head} ${word} ${tail}`;\n        shift = pos + 2;\n        pos = raw.indexOf(word, shift);\n      }\n    }\n    raw = raw.trim();\n\n    // postprocess\n    raw = raw.replace(/###42@@@/g, '<>'); // back to original notation <>\n    raw = raw.replace(/###43@@@/g, '>=');\n    raw = raw.replace(/###44@@@/g, '<=');\n\n    // split\n    let parts = raw.split(' ');\n    let str = [];\n    let inStr = 0;\n    for (let part of parts) {\n      let posQuoteFirst = part.indexOf(\"'\");\n      if (posQuoteFirst !== -1) {\n        inStr++;\n        if (inStr === 1) { // string start\n          str = [];\n        }\n      }\n\n      if (inStr) { // inside 'string with spaces'\n        str.push(part);\n        let posQuoteSecond = part.indexOf(\"'\", posQuoteFirst+1);\n        if (posQuoteSecond !== -1) {\n          inStr = 2;\n        }\n      } else {\n        if (part.length > 0) {\n          let type = TOKEN_UNKNOWN;\n          if (operators.indexOf(part) !== -1) {\n            if (part === '(' || part === ')') {\n              type = TOKEN_PARENTHESIS\n            } else {\n              type = TOKEN_OPERATOR;\n            }\n          } else {\n            if (this._mayBeNumber(part)) {\n              if (this._mayBeFloat(part)) {\n                part = parseFloat(part);\n              } else {\n                part = parseInt(part);\n              }\n              type = TOKEN_NUMBER;\n            } else {\n              if (part === 'TRUE' || part === 'FALSE') {\n                type = TOKEN_BOOLEAN;\n                if (part === 'TRUE') {\n                  part = true;\n                } else {\n                  part = false;\n                }\n              } else {\n                type = TOKEN_VARIABLE;\n              }\n            }\n          }\n          tokens.push({value:part, type});\n        }\n      }\n\n      if (inStr > 1) { // string end\n        str = str.join(' ');\n        str = str.replace(/'/g, '');\n        tokens.push({value:str, type: TOKEN_STRING});\n        str = [];\n        inStr = 0;\n      }\n    }\n\n    if (inStr) {\n      error = `${errorSource}: ${ERROR_RULE_STRING_NO_QUOTE}`;\n      return [tokens, error];\n    }\n\n    tokens = this.checkUnaryMinus(tokens);\n\n    return [tokens, error];\n  }\n\n  /**\n   * Shunting yard algorithm - converting infix notation to reverse polish notation\n   * https://en.wikipedia.org/wiki/Shunting_yard_algorithm\n   *\n   * @param tokens {*[]}\n   * @param errorSource {string}\n   * @returns {*[][]|(*[]|string)[]}\n   * @private\n   */\n  _parse(tokens, errorSource) {\n    let error = null;\n    let output = [];\n    let stack = [];\n    for (let token of tokens) {\n      switch (token.type) {\n        case TOKEN_BOOLEAN:\n        case TOKEN_NUMBER:\n        case TOKEN_STRING:\n        case TOKEN_VARIABLE:\n          output.push(token);\n          break;\n\n        case TOKEN_OPERATOR: {\n          let operatorCurrent = token;\n          while (stack.length) {\n            let operatorTop = stack[stack.length - 1];\n            if (\n              operatorTop.type === TOKEN_OPERATOR && (\n                (this._operatorHasLeftAssociativity(operatorCurrent.value) && this._operatorPriority(operatorCurrent.value) <= this._operatorPriority(operatorTop.value))\n                ||\n                (!this._operatorHasLeftAssociativity(operatorCurrent.value) && this._operatorPriority(operatorCurrent.value) < this._operatorPriority(operatorTop.value))\n              )\n            ) {\n              output.push(operatorTop);\n              stack.pop();\n            } else {\n              break;\n            }\n          }\n          stack.push(operatorCurrent);\n        }\n        break;\n\n        case TOKEN_PARENTHESIS: {\n          if (token.value === '(') {\n            stack.push(token);\n          }\n          if (token.value === ')') {\n            let pe = false;\n            while (stack.length) {\n              let operatorTop = stack[stack.length - 1];\n              if (operatorTop.value === '(') {\n                pe = true;\n                break;\n              } else {\n                output.push(operatorTop);\n                stack.pop();\n              }\n            }\n            if (!pe) {\n              error = `${errorSource}: ${ERROR_RULE_PARENTHESES_1}`;\n              return [[], error];\n            }\n            stack.pop();\n          }\n        }\n        break;\n      }\n    }\n\n    while(stack.length) {\n      let operatorTop = stack[stack.length-1];\n      if(operatorTop.value === '(' || operatorTop.value === ')') {\n        error = `${errorSource}: ${ERROR_RULE_PARENTHESES_2}`;\n        return [[], error];\n      }\n      output.push(operatorTop);\n      stack.pop();\n    }\n\n    return [output, null];\n  }\n\n  /**\n   * Collect variable names from parsed reverse polish notation\n   */\n  _collectVariables(calc) {\n    let variables = [];\n    for (let token of calc) {\n      if (token.type === TOKEN_VARIABLE) {\n        let exist = variables.includes(token.value);\n        if (!exist) {\n          variables.push(token.value);\n        }\n      }\n    }\n    return variables;\n  }\n\n  /**\n   * Get parsing error\n   */\n  getError() {\n    return this.error;\n  }\n\n  /**\n   * Has rule precondition?\n   * @returns {boolean}\n   */\n  hasPrecondition() {\n    return this.precalc.length > 0;\n  }\n\n  /**\n   * Get prepared reverse polish notation from this.precalc\n   * @returns {string}\n   */\n  getPreconditionCalcString() {\n    let str = '';\n    str = this.precalc.map(token => token.value).join(' ');\n    return str;\n  }\n\n  /**\n   * Get prepared reverse polish notation from this.calc\n   * @returns {string}\n   */\n  getConditionCalcString() {\n    let str = '';\n    str = this.calc.map(token => token.value).join(' ');\n    return str;\n  }\n\n  /**\n   * @param variables\n   * @param factsExisting\n   * @param factsMissing\n   */\n  checkWantedVariables(variables, factsExisting, factsMissing) {\n    let result = true;\n    for (let variable of variables) {\n      if (factsExisting[variable] === undefined) {\n        factsMissing.push(variable);\n        result = false; // rule variable is absent\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Calc prepared reverse polish notation in calc\n   * @param facts\n   * @param calc\n   * @param isPrecondition\n   * @returns {boolean}\n   */\n  check (facts, calc, isPrecondition) {\n    let result = false;\n    // let allowConsoleLog = !PROD;\n    try {\n      // calc reverse polish notation\n      let stack = [];\n      for (let item of calc) {\n        let token = Object.assign({}, item);\n        switch (token.type) {\n          case TOKEN_BOOLEAN:\n          case TOKEN_NUMBER:\n          case TOKEN_STRING:\n            stack.push(token);\n            break;\n\n          case TOKEN_VARIABLE: {\n              let name = token.value;\n              let value = facts[name].value;\n              token.value = value;\n              stack.push(token);\n            }\n            break;\n\n          case TOKEN_OPERATOR: {\n              let operator = OPERATORS[token.value];\n              let a = null;\n              let b = null;\n              if (operator.arg_count === 2) {\n                b = stack.pop();\n                a = stack.pop();\n              } else {\n                a = stack.pop();\n              }\n              let result = operator.calc(a, b);\n              if (typeof result === 'number' && (isNaN(result) || !isFinite(result))) {\n                result = false;\n                // if (allowConsoleLog) {\n                //   console.error(`rule: ${this.condition}; error: NaN detected;`);\n                // }\n              }\n              stack.push({value: result, type: TOKEN_BOOLEAN});\n            }\n            break;\n        }\n      }\n\n      if (stack.length === 1) {\n        result = stack[0].value;\n      } else {\n        // error\n        let conditionStr = isPrecondition ? this.precondition : this.condition;\n        this.error = `rule: ${conditionStr}; error: calc failed (${JSON.stringify(stack)})`;\n        // if (allowConsoleLog) {\n        //   console.error(this.error);\n        // }\n      }\n    } catch (error) {\n      let conditionStr = isPrecondition ? this.precondition : this.condition;\n      this.error = `rule: ${conditionStr}; error in condition`;\n      // if (allowConsoleLog) {\n      //   this.error = `rule: ${this.condition}; error: ${error.message};`;\n      //   console.error(this.error);\n      // }\n    }\n\n    return result;\n  }\n}\n\nmodule.exports = {Rule}", "'use strict';\n\nconst ERROR_FACT_NAME_ABSENT = 'Fact name cannot be absent';\nconst ERROR_FACT_NAME_EMPTY  = 'Fact name cannot be empty';\nconst ERROR_FACT_VALUE_ABSENT = 'Fact value cannot be absent';\n\nmodule.exports = {\n  ERROR_FACT_NAME_ABSENT,\n  ERROR_FACT_NAME_EMPTY,\n  ERROR_FACT_VALUE_ABSENT,\n}", "'use strict';\n\nconst ERROR_STUGNA_SPACE_IN_FACT_NAME = 'Try to add fact with spaces in name: ';\nconst ERROR_STUGNA_PERIODIC_RULES = 'Periodic rules detected';\n\nmodule.exports = {\n  ERROR_STUGNA_SPACE_IN_FACT_NAME,\n  ERROR_STUGNA_PERIODIC_RULES\n}\n", "'use strict';\n\nconst {Fact} = require(\"./fact\");\nconst {Rule} = require(\"./rule\");\nconst {\n  ERROR_FACT_NAME_ABSENT,\n  ERROR_FACT_NAME_EMPTY,\n  ERROR_FACT_VALUE_ABSENT,\n} = require('./errors-fact');\nconst {\n  ERROR_STUGNA_SPACE_IN_FACT_NAME,\n  ERROR_STUGNA_PERIODIC_RULES,\n} = require('./errors-stugna-es');\n\nconst regexpWhiteSpaces = new RegExp('\\\\s+', 'g');\n\n/**\n *\n */\nclass StugnaES {\n  // fields\n  _rules;\n  _facts;\n  _events;\n  _toSaveEvents;\n  _toExplainMore;\n  _passCountMax;\n  _factsAreOrdered;\n\n  /**\n   * @param options {null|Object}\n   */\n  constructor(options = null) {\n    let toSaveEvents = true;\n    let toExplainMore = false;\n    let passCountMax = 16;\n    if (options) {\n      if (options.toSaveEvents !== undefined) {\n        toSaveEvents = options.toSaveEvents;\n      }\n      if (options.toExplainMore !== undefined) {\n        toExplainMore = options.toExplainMore;\n      }\n      if (options.passCountMax !== undefined) {\n        passCountMax = options.passCountMax;\n      }\n    }\n    this._rules  = [];\n    this._facts  = {};\n    this._events = [];\n    this._toSaveEvents  = toSaveEvents;\n    this._toExplainMore = toExplainMore;\n    this._passCountMax  = passCountMax;\n    this._factsAreOrdered = true;\n  }\n\n  /**\n   * @param brief {string}\n   * @param more {string|null}\n   * @param subject {string|null}\n   */\n  eventAdd(brief, more, subject) {\n    if (this._toSaveEvents) {\n      let event = {brief}\n      if (more) {\n        event.more = more;\n      }\n      if (subject) {\n        event.subject = subject;\n      }\n      this._events.push(event);\n    }\n  }\n\n  /**\n   *\n   */\n  eventsAll() {\n    return this._events.map(event => event);\n  }\n\n  /**\n   *\n   */\n  eventsClear() {\n    this._events = [];\n  }\n\n  /**\n   * @param name {string|null|undefined}\n   * @param value {string|number|boolean|null|undefined}\n   * @returns {boolean}\n   * @private\n   */\n  _factIsValid(name, value) {\n    if (name === null || name === undefined) {\n      this.eventAdd('fact error', ERROR_FACT_NAME_ABSENT);\n      return false;\n    }\n    name = name.toString();\n    let nameTrimmed = name.trim()\n    if (nameTrimmed.length === 0) {\n      this.eventAdd('fact error', ERROR_FACT_NAME_EMPTY);\n      return false;\n    }\n    if (regexpWhiteSpaces.test(name)) {\n      this.eventAdd('fact error', ERROR_STUGNA_SPACE_IN_FACT_NAME + name);\n      return false;\n    }\n    if (value === null || value === undefined) {\n      this.eventAdd('fact error', ERROR_FACT_VALUE_ABSENT);\n      return false;\n    }\n    return true\n  }\n\n  /**\n   * @param name {string|null|undefined}\n   * @param value {string|number|boolean|null|undefined}\n   * @param description {string|null|undefined}\n   * @param toRegularize {boolean}\n   */\n  factAdd({name, value, description}, isTrigger = true) {\n    if (!this._factIsValid(name, value)) {\n      return\n    }\n\n    let subject = description;\n    if (!subject) {\n      subject = `${name}: ${value}`;\n    }\n\n    let factNew = new Fact(name, value, subject);\n    let factOld = this._facts[name];\n    if (factOld) {\n      factOld.history.push(`init: ${subject}`);\n      factNew.history = factOld.history;\n    }\n    this._facts[name] = factNew;\n\n    this.eventAdd('fact add', null, subject);\n    if (isTrigger) {\n      this._order();\n    }\n  }\n\n  /**\n   * @param name\n   * @returns {boolean}\n   */\n  factIsKnown(name) {\n    return (this._facts[name] !== undefined)\n  }\n\n  /**\n   * @param name {string}\n   * @returns {{name, value: *, history: (*|string[]|[string]|History), changed}|null}\n   */\n  factGet(name) {\n    if (!this._facts[name]) {\n      return null;\n    }\n    let value = this._facts[name].value;\n    let history = this._facts[name].history;\n    let changed = this._facts[name].changed;\n    return {name, value, history, changed};\n  }\n\n  /**\n   * @param name {string}\n   * @returns {string[]}\n   */\n  factGetPredecessorsWanted(name) {\n    let predecessors = [];\n    for (let rule of this._rules) {\n      if (rule.fact === name || rule.factElse === name) {\n        for (let predecessor of rule.variables) {\n          if (!predecessors.includes(predecessor)) {\n            predecessors.push(predecessor);\n          }\n        }\n      }\n    }\n    let childrenAll = []; // may contain duplicates\n    for (let predecessor1 of predecessors) {\n      let children = this.factGetPredecessorsWanted(predecessor1);\n      childrenAll = childrenAll.concat(children);\n    }\n    for (let fact of childrenAll) { // filter duplicates\n      if (!predecessors.includes(fact)) {\n        predecessors.push(fact);\n      }\n    }\n    return predecessors;\n  }\n\n  /**\n   * @param name {string}\n   * @returns {string[]}\n   */\n  factGetPredecessorsUnknown(name) {\n    // find all wanted facts\n    let wanted = this.factGetPredecessorsWanted(name);\n\n    // exclude known facts\n    let unknownWithRules = [];\n    for (let fact of wanted) {\n      if (this._facts[fact] === undefined) {\n        unknownWithRules.push(fact);\n      }\n    }\n\n    // exclude facts that can be produced by the rules\n    let unknownWithoutRules = [];\n    for (let fact of unknownWithRules) {\n      let noRuleForFact = true;\n      for (let rule of this._rules) {\n        if (rule.fact === fact || rule.factElse === fact) {\n          noRuleForFact = false;\n          break;\n        }\n      }\n      if (noRuleForFact) {\n        unknownWithoutRules.push(fact);\n      }\n    }\n\n    return unknownWithoutRules;\n  }\n\n  /**\n   * @param facts {Object[]}\n   * @param isTrigger {boolean}\n   */\n  factsImport(facts, isTrigger = true) {\n    let addedCount = 0;\n    for (let fact of facts) {\n      if (!this._factIsValid(fact.name, fact.value)) {\n        continue;\n      }\n      this.factAdd(fact, false);\n      addedCount++;\n    }\n    if (isTrigger && addedCount > 0) {\n      this._order();\n    }\n  }\n\n  /**\n   * @returns {{name: string, value: (number|string), history: string[], changed: boolean}[]}\n   */\n  factsAllAsArray() {\n    return Object.values(this._facts).map(fact => { return {\n      name: fact.name,\n      value: fact.value,\n      history: fact.history,\n      changed: fact.changed\n    } });\n  }\n\n  /**\n   * @returns {object}\n   */\n  factsAllAsMap() {\n    let facts = {};\n    for (let name in this._facts) {\n      facts[name] = this._facts[name].value;\n    }\n    return facts;\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  factsAreOrdered () {\n    return this._factsAreOrdered;\n  }\n\n  /**\n   *\n   */\n  factsClear() {\n    this._facts = {};\n    this.eventAdd('facts clear', 'all facts are cleaned');\n  }\n\n  /**\n   * @param condition {string}\n   * @param factName {string}\n   * @param factValue {string}\n   * @param priority {number}\n   * @param description {string}\n   * @param factNameElse {string}\n   * @param factValueElse {string}\n   * @param final {number}\n   * @param precondition {string}\n   * @param missing {number|string|null}\n   * @param isTrigger {boolean}\n   */\n  ruleAdd({ condition,\n            factName, factValue,\n            priority, description,\n            factNameElse, factValueElse,\n            final, precondition, missing\n          }, isTrigger = true) {\n    let ruleError = Rule.validate(condition, factName, factValue, factNameElse, factValueElse);\n    if (ruleError) {\n      this.eventAdd('rule error', ruleError, description); // validation errors\n      return;\n    }\n\n    let rule = new Rule(condition, factName, factValue, priority, description, factNameElse, factValueElse, final, precondition, missing);\n    ruleError = rule.getError();\n    if (ruleError) {\n      let subject = rule.description;\n      this.eventAdd('rule error', ruleError, subject); // parsing errors\n      return\n    }\n\n    this._rules.push(rule);\n    this._rules.sort((a, b) => {\n      return a.priority - b.priority; // by priority ASC\n    });\n    this.eventAdd('rule add', null, rule.description);\n    if (isTrigger) {\n      this._order();\n    }\n  }\n\n  /**\n   * @param rules {object[]}\n   * @param isTrigger {boolean}\n   */\n  rulesImport(rules, isTrigger = true) {\n    for (let rule of rules) {\n      let ruleError = Rule.validate(rule.condition, rule.factName, rule.factValue, rule.factNameElse, rule.factValueElse);\n      if (ruleError) {\n        let subject = rule.description;\n        if (!subject) {\n          subject = Rule.createDescription(rule.condition, rule.factName, rule.factValue, rule.factNameElse, rule.factValueElse);\n        }\n        this.eventAdd('rule error', ruleError, subject);\n        continue;\n      }\n\n      rule.priority = rule.priority ? rule.priority : 1;\n      this.ruleAdd(rule, false);\n    }\n    if (isTrigger) {\n      this._order();\n    }\n  }\n\n  /**\n   * @returns {object[]}\n   */\n  rulesAll() {\n    let all = [];\n    for (let rule of this._rules) {\n      let item = {\n        condition: rule.condition,\n        factName: rule.fact,\n        factValue: rule.value,\n        factNameElse: rule.factElse,\n        factValueElse: rule.valueElse,\n        priority: rule.priority,\n        description: rule.description,\n        final: rule.final\n      }\n      for (let prop in item) {\n        if (item[prop] === undefined) {\n          delete item[prop];\n        }\n      }\n      all.push(item);\n    }\n    return all;\n  }\n\n  /**\n   *\n   */\n  rulesClear() {\n    this._rules = [];\n    this.eventAdd('rules clear', 'all rules are cleaned');\n  }\n\n  /**\n   * @param factName\n   * @param factValue\n   * @param eventName\n   * @param ruleDescription\n   * @private\n   */\n  _applyFact(factName, factValue, eventName, ruleDescription) {\n    let factIsChanged = 0;\n    let factNew = new Fact(factName, factValue, `${eventName}: ${ruleDescription}`);\n    let factOld = this._facts[factName];\n    if (!factOld || factOld.value !== factNew.value) { // has changes\n      if (factOld) {\n        factOld.history.push(`${eventName}: ${ruleDescription}`);\n        factNew.history = factOld.history;\n      }\n      factNew.changed = true;\n      this._facts[factName] = factNew;\n      this.eventAdd(eventName, null, ruleDescription);\n      factIsChanged = 1;\n    }\n    return factIsChanged;\n  }\n\n  /**\n   * @param obj\n   * @returns {any}\n   * @private\n   */\n  _deepCopy(obj) {\n    const str = JSON.stringify(obj);\n    return JSON.parse(str);\n  }\n\n  /**\n   * Fix missing facts by default values into temp map\n   * @param factsExisting\n   * @param factsMissing\n   * @param defaultValue\n   * @returns {*}\n   * @private\n   */\n  _fixFactsMissing(factsExisting, factsMissing, defaultValue) {\n    let factsTmp = this._deepCopy(factsExisting);\n    for (let factName of factsMissing) {\n      const fact = new Fact(factName, defaultValue, '');\n      factsTmp[factName] = fact;\n    }\n    return factsTmp;\n  }\n\n  /**\n   * Regularize all rules and facts\n   */\n  _order () {\n    this._factsAreOrdered = false;\n    let passCount = 1;\n    let finalRuleHappened = false;\n    while (passCount <= this._passCountMax) {\n      // one pass - check all rules\n      let factsChanged = 0;\n      for (let rule of this._rules) {\n        let factsMissing = [];\n\n        // precondition\n        if (rule.hasPrecondition()) {\n          // check precondition variables\n          if (!rule.checkWantedVariables(rule.prevariables, this._facts, factsMissing)) {\n            if (this._toExplainMore) {\n              this.eventAdd('rule skip', `missing facts in precondition: ${factsMissing.join(', ')};`, rule.description);\n            }\n            continue;\n          }\n\n          // check precondition\n          if (!rule.check(this._facts, rule.precalc, true)) {\n            if (this._toExplainMore) {\n              this.eventAdd('rule skip', `precondition not met`, rule.description);\n            }\n            continue;\n          }\n        }\n\n        // check condition variables\n        let factsAll = this._facts;\n        factsMissing = [];\n        if (!rule.checkWantedVariables(rule.variables, this._facts, factsMissing)) {\n          if (rule.missing === undefined) {\n            if (this._toExplainMore) {\n              this.eventAdd('rule skip', `missing fact in condition: ${factsMissing.join(', ')};`, rule.description);\n            }\n            continue;\n          } else {\n            factsAll = this._fixFactsMissing(this._facts, factsMissing, rule.missing);\n          }\n        }\n\n        // check condition\n        if (rule.check(factsAll, rule.calc, false)) {\n          factsChanged += this._applyFact(rule.fact, rule.value, 'rule ok', rule.description);\n          finalRuleHappened = (rule.final === 1 || rule.final === 3);\n        } else {\n          if (rule.hasElse()) {\n            factsChanged += this._applyFact(rule.factElse, rule.valueElse, 'rule else', rule.description);\n            finalRuleHappened = (rule.final === 2 || rule.final === 3);\n          }\n        }\n\n        if (finalRuleHappened) {\n          this.eventAdd('rule final', `Final rule happened`);\n          break;\n        }\n      }\n\n      this.eventAdd('rules passed', `Rules pass count is ${passCount}`);\n\n      if (!factsChanged) {\n        this._factsAreOrdered = true;\n        break;\n      }\n\n      if (finalRuleHappened) {\n        this._factsAreOrdered = true;\n        break;\n      }\n\n      passCount++;\n    }\n\n    if (!this._factsAreOrdered && this._toSaveEvents) {\n      this.eventAdd('rules error', ERROR_STUGNA_PERIODIC_RULES);\n    }\n  }\n}\n\n/**\n *\n * @param condition {string}\n * @param facts {[{name: string, value: number|string}]}\n * @returns {[boolean, null|string]}\n */\nfunction ruleApply(condition, facts) {\n  let result = false;\n  let error = null;\n\n  // facts\n  let factsMap = {};\n  for (let fact of facts) {\n    if (!fact.name) continue;\n    factsMap[fact.name] = {value:fact.value};\n  }\n\n  // rule\n  let rule = new Rule(condition, 'fact-name', 'fact-value', 10, 'description');\n  if (rule.error) {\n    error = rule.error;\n  } else {\n    let factsMissing = [];\n    if (!rule.checkWantedVariables(rule.variables, factsMap, factsMissing)) {\n      error = `missing facts: ${factsMissing.join(', ')}`;\n      return [false, error];\n    }\n\n    result = rule.check(factsMap, rule.calc, false);\n    if (rule.error) {\n      error = rule.error;\n    }\n  }\n\n  return [result, error];\n}\n\nmodule.exports = {StugnaES, ruleApply}"],
  "mappings": "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",
  "names": ["result"]
}
