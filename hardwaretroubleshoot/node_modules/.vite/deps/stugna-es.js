import {
  __commonJS,
  __publicField
} from "./chunk-TYRVL62N.js";

// node_modules/stugna-es/fact.js
var require_fact = __commonJS({
  "node_modules/stugna-es/fact.js"(exports, module) {
    "use strict";
    var Fact = class {
      /**
       *
       * @param name {string}
       * @param value {boolean|number|string}
       * @param description {string}
       */
      constructor(name, value, description) {
        this.name = name;
        if (typeof value === "string" && value.length > 1) {
          value = value.replace(/'/g, "");
          if (value === "TRUE") {
            value = true;
          }
          if (value === "FALSE") {
            value = false;
          }
        }
        this.value = value;
        this.history = [description];
        this.changed = false;
      }
    };
    module.exports = { Fact };
  }
});

// node_modules/stugna-es/errors-rule.js
var require_errors_rule = __commonJS({
  "node_modules/stugna-es/errors-rule.js"(exports, module) {
    "use strict";
    var ERROR_RULE_CONDITION_EMPTY = "Rule condition cannot be empty";
    var ERROR_RULE_FACT_NAME_EMPTY = "Fact name cannot be empty";
    var ERROR_RULE_FACT_NAME_HAS_SPACES = "Fact name cannot contain spaces";
    var ERROR_RULE_FACT_VALUE_EMPTY = "Fact value cannot be empty";
    var ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES = "factValueElse cannot contain spaces";
    var ERROR_RULE_ELSE_FACT_NAME_ABSENT = "If you use factValueElse you have to fill factNameElse";
    var ERROR_RULE_ELSE_FACT_VALUE_ABSENT = "If you use factNameElse you have to fill factValueElse";
    var ERROR_RULE_STRING_NO_QUOTE = "there is no ' to close string value";
    var ERROR_RULE_PARENTHESES_1 = "parentheses mismatched (1)";
    var ERROR_RULE_PARENTHESES_2 = "parentheses mismatched (2)";
    module.exports = {
      ERROR_RULE_CONDITION_EMPTY,
      ERROR_RULE_FACT_NAME_EMPTY,
      ERROR_RULE_FACT_NAME_HAS_SPACES,
      ERROR_RULE_FACT_VALUE_EMPTY,
      ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES,
      ERROR_RULE_ELSE_FACT_NAME_ABSENT,
      ERROR_RULE_ELSE_FACT_VALUE_ABSENT,
      ERROR_RULE_STRING_NO_QUOTE,
      ERROR_RULE_PARENTHESES_1,
      ERROR_RULE_PARENTHESES_2
    };
  }
});

// node_modules/stugna-es/rule.js
var require_rule = __commonJS({
  "node_modules/stugna-es/rule.js"(exports, module) {
    "use strict";
    var {
      ERROR_RULE_CONDITION_EMPTY,
      ERROR_RULE_FACT_NAME_EMPTY,
      ERROR_RULE_FACT_NAME_HAS_SPACES,
      ERROR_RULE_FACT_VALUE_EMPTY,
      ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES,
      ERROR_RULE_ELSE_FACT_NAME_ABSENT,
      ERROR_RULE_ELSE_FACT_VALUE_ABSENT,
      ERROR_RULE_STRING_NO_QUOTE,
      ERROR_RULE_PARENTHESES_1,
      ERROR_RULE_PARENTHESES_2
    } = require_errors_rule();
    var OPERATORS = {
      "(": { priority: 4, arg_count: 2, left_associativity: 1, calc: null },
      ")": { priority: 4, arg_count: 2, left_associativity: 1, calc: null },
      "+": { priority: 3, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value + b.value;
      } },
      "-": { priority: 3, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value - b.value;
      } },
      "*": { priority: 3, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value * b.value;
      } },
      "/": { priority: 3, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value / b.value;
      } },
      "<": { priority: 2, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value < b.value;
      } },
      "<=": { priority: 2, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value <= b.value;
      } },
      ">": { priority: 2, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value > b.value;
      } },
      ">=": { priority: 2, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value >= b.value;
      } },
      "=": { priority: 2, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value === b.value;
      } },
      "<>": { priority: 2, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value !== b.value;
      } },
      "LIKE": { priority: 2, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value.toString().indexOf(b.value.toString()) !== -1;
      } },
      "AND": { priority: 1, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value && b.value;
      } },
      "OR": { priority: 1, arg_count: 2, left_associativity: 1, calc: function(a, b) {
        return a.value || b.value;
      } },
      "NOT": { priority: 1, arg_count: 1, left_associativity: 0, calc: function(a) {
        return !a.value;
      } }
    };
    var CHAR_CODE_0 = 48;
    var CHAR_CODE_9 = 57;
    var TOKEN_UNKNOWN = 0;
    var TOKEN_BOOLEAN = 1;
    var TOKEN_NUMBER = 2;
    var TOKEN_STRING = 3;
    var TOKEN_VARIABLE = 4;
    var TOKEN_OPERATOR = 5;
    var TOKEN_PARENTHESIS = 6;
    var regexpWhiteSpaces = new RegExp("\\s+", "g");
    var Rule = class _Rule {
      /**
       * @param condition {string}
       * @param factName {string}
       * @param factValue {number|string|null}
       * @param priority {number}
       * @param description {string}
       * @param factNameElse {string|undefined}
       * @param factValueElse {number|string|undefined}
       * @param final {number|undefined}
       * @param precondition {string|null|undefined}
       * @param missing {number|string|null}
       */
      constructor(condition, factName, factValue, priority, description, factNameElse, factValueElse, final, precondition, missing) {
        this.condition = condition;
        this.precondition = precondition !== null ? precondition : void 0;
        this.fact = factName;
        this.value = factValue;
        this.factElse = factNameElse !== null ? factNameElse : void 0;
        this.valueElse = factValueElse !== null ? factValueElse : void 0;
        if (priority && priority > 0)
          this.priority = priority;
        else
          this.priority = 1;
        if (description)
          this.description = description;
        else
          this.description = _Rule.createDescription(condition, factName, factValue, factNameElse, factValueElse);
        if (final && final >= 1 && final <= 3)
          this.final = final;
        else
          this.final = void 0;
        this.missing = missing !== null ? missing : void 0;
        this.error = null;
        this.precalc = [];
        this.prevariables = [];
        this.calc = [];
        this.variables = [];
        let tokens = [];
        if (this.precondition !== void 0) {
          [tokens, this.error] = this._tokenize(this.precondition, "Precondition");
          if (this.error === null) {
            [this.precalc, this.error] = this._parse(tokens, "Precondition");
            if (this.error === null) {
              this.prevariables = this._collectVariables(this.precalc);
            }
          }
        }
        if (this.error === null) {
          [tokens, this.error] = this._tokenize(condition, "Condition");
          if (this.error === null) {
            [this.calc, this.error] = this._parse(tokens, "Condition");
            if (this.error === null) {
              this.variables = this._collectVariables(this.calc);
            }
          }
        }
      }
      /**
       *
       * @param condition
       * @param factName
       * @param factValue
       * @param factElse
       * @param factNameElse
       * @param factValueElse
       * @returns {string}
       */
      static createDescription(condition, factName, factValue, factNameElse, factValueElse) {
        let postfix = "";
        if (factNameElse) {
          postfix = ` / {${factNameElse}: ${factValueElse}}`;
        }
        return `${condition} / {${factName}: ${factValue}}${postfix}`;
      }
      /**
       * @param name {string}
       */
      _operatorHasLeftAssociativity(name) {
        let operator = OPERATORS[name];
        if (!operator) {
          return null;
        }
        return operator.left_associativity;
      }
      /**
       * @param name {string}
       */
      _operatorPriority(name) {
        let operator = OPERATORS[name];
        if (!operator) {
          return null;
        }
        return operator.priority;
      }
      _mayBeNumber(str) {
        if (!str) {
          return false;
        }
        let code = str.charCodeAt(0);
        return code >= CHAR_CODE_0 && code <= CHAR_CODE_9;
      }
      _mayBeFloat(str) {
        if (!str) {
          return false;
        }
        return str.indexOf(".") !== -1;
      }
      /**
       * Validate rule inputs
       */
      static validate(condition, fact, value, factElse, valueElse) {
        if (!condition) {
          return ERROR_RULE_CONDITION_EMPTY;
        }
        if (!fact) {
          return ERROR_RULE_FACT_NAME_EMPTY;
        }
        if (regexpWhiteSpaces.test(fact)) {
          return ERROR_RULE_FACT_NAME_HAS_SPACES;
        }
        if (value === null || value === void 0) {
          return ERROR_RULE_FACT_VALUE_EMPTY;
        }
        if (factElse || valueElse) {
          if (factElse && (valueElse === null || valueElse === void 0)) {
            return ERROR_RULE_ELSE_FACT_VALUE_ABSENT;
          }
          if (valueElse && (factElse === null || factElse === void 0)) {
            return ERROR_RULE_ELSE_FACT_NAME_ABSENT;
          }
          if (regexpWhiteSpaces.test(factElse)) {
            return ERROR_RULE_ELSE_FACT_NAME_HAS_SPACES;
          }
        }
        return null;
      }
      /**
       * @returns {boolean}
       */
      hasElse() {
        return this.factElse !== null && this.factElse !== void 0;
      }
      /**
       * @param tokens {Object[]}
       */
      checkUnaryMinus(tokens) {
        let result = [];
        let tokenPrev = null;
        for (let i = 0; i < tokens.length; i++) {
          let tokenCurrent = tokens[i];
          let tokenNext = null;
          let tokenNextIsNumber = false;
          if (i < tokens.length - 1) {
            tokenNext = tokens[i + 1];
            tokenNextIsNumber = tokenNext.type === TOKEN_NUMBER;
          }
          if (tokenCurrent.type === TOKEN_OPERATOR && tokenCurrent.value === "-" && tokenNextIsNumber) {
            let isUnaryMinus = false;
            if (tokenPrev === null) {
              isUnaryMinus = true;
            } else {
              if (tokenPrev.type !== TOKEN_NUMBER) {
                isUnaryMinus = true;
              }
            }
            if (isUnaryMinus) {
              tokenNext.value *= -1;
            } else {
              result.push(tokenCurrent);
            }
          } else {
            result.push(tokenCurrent);
          }
          tokenPrev = tokenCurrent;
        }
        return result;
      }
      /**
       * Lexical analysis
       * @param raw {string}
       * @param errorSource {string}
       * @returns {*[][]}
       * @private
       */
      _tokenize(raw, errorSource) {
        let tokens = [];
        let error = null;
        raw = raw.replace(/<>/g, "###42@@@");
        raw = raw.replace(/>=/g, "###43@@@");
        raw = raw.replace(/<=/g, "###44@@@");
        let operators = Object.keys(OPERATORS);
        for (let word of operators) {
          let shift = 0;
          let pos = raw.indexOf(word, shift);
          while (pos !== -1) {
            let head = raw.substring(0, pos);
            pos += word.length;
            let tail = raw.substring(pos);
            raw = `${head} ${word} ${tail}`;
            shift = pos + 2;
            pos = raw.indexOf(word, shift);
          }
        }
        raw = raw.trim();
        raw = raw.replace(/###42@@@/g, "<>");
        raw = raw.replace(/###43@@@/g, ">=");
        raw = raw.replace(/###44@@@/g, "<=");
        let parts = raw.split(" ");
        let str = [];
        let inStr = 0;
        for (let part of parts) {
          let posQuoteFirst = part.indexOf("'");
          if (posQuoteFirst !== -1) {
            inStr++;
            if (inStr === 1) {
              str = [];
            }
          }
          if (inStr) {
            str.push(part);
            let posQuoteSecond = part.indexOf("'", posQuoteFirst + 1);
            if (posQuoteSecond !== -1) {
              inStr = 2;
            }
          } else {
            if (part.length > 0) {
              let type = TOKEN_UNKNOWN;
              if (operators.indexOf(part) !== -1) {
                if (part === "(" || part === ")") {
                  type = TOKEN_PARENTHESIS;
                } else {
                  type = TOKEN_OPERATOR;
                }
              } else {
                if (this._mayBeNumber(part)) {
                  if (this._mayBeFloat(part)) {
                    part = parseFloat(part);
                  } else {
                    part = parseInt(part);
                  }
                  type = TOKEN_NUMBER;
                } else {
                  if (part === "TRUE" || part === "FALSE") {
                    type = TOKEN_BOOLEAN;
                    if (part === "TRUE") {
                      part = true;
                    } else {
                      part = false;
                    }
                  } else {
                    type = TOKEN_VARIABLE;
                  }
                }
              }
              tokens.push({ value: part, type });
            }
          }
          if (inStr > 1) {
            str = str.join(" ");
            str = str.replace(/'/g, "");
            tokens.push({ value: str, type: TOKEN_STRING });
            str = [];
            inStr = 0;
          }
        }
        if (inStr) {
          error = `${errorSource}: ${ERROR_RULE_STRING_NO_QUOTE}`;
          return [tokens, error];
        }
        tokens = this.checkUnaryMinus(tokens);
        return [tokens, error];
      }
      /**
       * Shunting yard algorithm - converting infix notation to reverse polish notation
       * https://en.wikipedia.org/wiki/Shunting_yard_algorithm
       *
       * @param tokens {*[]}
       * @param errorSource {string}
       * @returns {*[][]|(*[]|string)[]}
       * @private
       */
      _parse(tokens, errorSource) {
        let error = null;
        let output = [];
        let stack = [];
        for (let token of tokens) {
          switch (token.type) {
            case TOKEN_BOOLEAN:
            case TOKEN_NUMBER:
            case TOKEN_STRING:
            case TOKEN_VARIABLE:
              output.push(token);
              break;
            case TOKEN_OPERATOR:
              {
                let operatorCurrent = token;
                while (stack.length) {
                  let operatorTop = stack[stack.length - 1];
                  if (operatorTop.type === TOKEN_OPERATOR && (this._operatorHasLeftAssociativity(operatorCurrent.value) && this._operatorPriority(operatorCurrent.value) <= this._operatorPriority(operatorTop.value) || !this._operatorHasLeftAssociativity(operatorCurrent.value) && this._operatorPriority(operatorCurrent.value) < this._operatorPriority(operatorTop.value))) {
                    output.push(operatorTop);
                    stack.pop();
                  } else {
                    break;
                  }
                }
                stack.push(operatorCurrent);
              }
              break;
            case TOKEN_PARENTHESIS:
              {
                if (token.value === "(") {
                  stack.push(token);
                }
                if (token.value === ")") {
                  let pe = false;
                  while (stack.length) {
                    let operatorTop = stack[stack.length - 1];
                    if (operatorTop.value === "(") {
                      pe = true;
                      break;
                    } else {
                      output.push(operatorTop);
                      stack.pop();
                    }
                  }
                  if (!pe) {
                    error = `${errorSource}: ${ERROR_RULE_PARENTHESES_1}`;
                    return [[], error];
                  }
                  stack.pop();
                }
              }
              break;
          }
        }
        while (stack.length) {
          let operatorTop = stack[stack.length - 1];
          if (operatorTop.value === "(" || operatorTop.value === ")") {
            error = `${errorSource}: ${ERROR_RULE_PARENTHESES_2}`;
            return [[], error];
          }
          output.push(operatorTop);
          stack.pop();
        }
        return [output, null];
      }
      /**
       * Collect variable names from parsed reverse polish notation
       */
      _collectVariables(calc) {
        let variables = [];
        for (let token of calc) {
          if (token.type === TOKEN_VARIABLE) {
            let exist = variables.includes(token.value);
            if (!exist) {
              variables.push(token.value);
            }
          }
        }
        return variables;
      }
      /**
       * Get parsing error
       */
      getError() {
        return this.error;
      }
      /**
       * Has rule precondition?
       * @returns {boolean}
       */
      hasPrecondition() {
        return this.precalc.length > 0;
      }
      /**
       * Get prepared reverse polish notation from this.precalc
       * @returns {string}
       */
      getPreconditionCalcString() {
        let str = "";
        str = this.precalc.map((token) => token.value).join(" ");
        return str;
      }
      /**
       * Get prepared reverse polish notation from this.calc
       * @returns {string}
       */
      getConditionCalcString() {
        let str = "";
        str = this.calc.map((token) => token.value).join(" ");
        return str;
      }
      /**
       * @param variables
       * @param factsExisting
       * @param factsMissing
       */
      checkWantedVariables(variables, factsExisting, factsMissing) {
        let result = true;
        for (let variable of variables) {
          if (factsExisting[variable] === void 0) {
            factsMissing.push(variable);
            result = false;
          }
        }
        return result;
      }
      /**
       * Calc prepared reverse polish notation in calc
       * @param facts
       * @param calc
       * @param isPrecondition
       * @returns {boolean}
       */
      check(facts, calc, isPrecondition) {
        let result = false;
        try {
          let stack = [];
          for (let item of calc) {
            let token = Object.assign({}, item);
            switch (token.type) {
              case TOKEN_BOOLEAN:
              case TOKEN_NUMBER:
              case TOKEN_STRING:
                stack.push(token);
                break;
              case TOKEN_VARIABLE:
                {
                  let name = token.value;
                  let value = facts[name].value;
                  token.value = value;
                  stack.push(token);
                }
                break;
              case TOKEN_OPERATOR:
                {
                  let operator = OPERATORS[token.value];
                  let a = null;
                  let b = null;
                  if (operator.arg_count === 2) {
                    b = stack.pop();
                    a = stack.pop();
                  } else {
                    a = stack.pop();
                  }
                  let result2 = operator.calc(a, b);
                  if (typeof result2 === "number" && (isNaN(result2) || !isFinite(result2))) {
                    result2 = false;
                  }
                  stack.push({ value: result2, type: TOKEN_BOOLEAN });
                }
                break;
            }
          }
          if (stack.length === 1) {
            result = stack[0].value;
          } else {
            let conditionStr = isPrecondition ? this.precondition : this.condition;
            this.error = `rule: ${conditionStr}; error: calc failed (${JSON.stringify(stack)})`;
          }
        } catch (error) {
          let conditionStr = isPrecondition ? this.precondition : this.condition;
          this.error = `rule: ${conditionStr}; error in condition`;
        }
        return result;
      }
    };
    module.exports = { Rule };
  }
});

// node_modules/stugna-es/errors-fact.js
var require_errors_fact = __commonJS({
  "node_modules/stugna-es/errors-fact.js"(exports, module) {
    "use strict";
    var ERROR_FACT_NAME_ABSENT = "Fact name cannot be absent";
    var ERROR_FACT_NAME_EMPTY = "Fact name cannot be empty";
    var ERROR_FACT_VALUE_ABSENT = "Fact value cannot be absent";
    module.exports = {
      ERROR_FACT_NAME_ABSENT,
      ERROR_FACT_NAME_EMPTY,
      ERROR_FACT_VALUE_ABSENT
    };
  }
});

// node_modules/stugna-es/errors-stugna-es.js
var require_errors_stugna_es = __commonJS({
  "node_modules/stugna-es/errors-stugna-es.js"(exports, module) {
    "use strict";
    var ERROR_STUGNA_SPACE_IN_FACT_NAME = "Try to add fact with spaces in name: ";
    var ERROR_STUGNA_PERIODIC_RULES = "Periodic rules detected";
    module.exports = {
      ERROR_STUGNA_SPACE_IN_FACT_NAME,
      ERROR_STUGNA_PERIODIC_RULES
    };
  }
});

// node_modules/stugna-es/stugna-es.js
var require_stugna_es = __commonJS({
  "node_modules/stugna-es/stugna-es.js"(exports, module) {
    var { Fact } = require_fact();
    var { Rule } = require_rule();
    var {
      ERROR_FACT_NAME_ABSENT,
      ERROR_FACT_NAME_EMPTY,
      ERROR_FACT_VALUE_ABSENT
    } = require_errors_fact();
    var {
      ERROR_STUGNA_SPACE_IN_FACT_NAME,
      ERROR_STUGNA_PERIODIC_RULES
    } = require_errors_stugna_es();
    var regexpWhiteSpaces = new RegExp("\\s+", "g");
    var StugnaES = class {
      /**
       * @param options {null|Object}
       */
      constructor(options = null) {
        // fields
        __publicField(this, "_rules");
        __publicField(this, "_facts");
        __publicField(this, "_events");
        __publicField(this, "_toSaveEvents");
        __publicField(this, "_toExplainMore");
        __publicField(this, "_passCountMax");
        __publicField(this, "_factsAreOrdered");
        let toSaveEvents = true;
        let toExplainMore = false;
        let passCountMax = 16;
        if (options) {
          if (options.toSaveEvents !== void 0) {
            toSaveEvents = options.toSaveEvents;
          }
          if (options.toExplainMore !== void 0) {
            toExplainMore = options.toExplainMore;
          }
          if (options.passCountMax !== void 0) {
            passCountMax = options.passCountMax;
          }
        }
        this._rules = [];
        this._facts = {};
        this._events = [];
        this._toSaveEvents = toSaveEvents;
        this._toExplainMore = toExplainMore;
        this._passCountMax = passCountMax;
        this._factsAreOrdered = true;
      }
      /**
       * @param brief {string}
       * @param more {string|null}
       * @param subject {string|null}
       */
      eventAdd(brief, more, subject) {
        if (this._toSaveEvents) {
          let event = { brief };
          if (more) {
            event.more = more;
          }
          if (subject) {
            event.subject = subject;
          }
          this._events.push(event);
        }
      }
      /**
       *
       */
      eventsAll() {
        return this._events.map((event) => event);
      }
      /**
       *
       */
      eventsClear() {
        this._events = [];
      }
      /**
       * @param name {string|null|undefined}
       * @param value {string|number|boolean|null|undefined}
       * @returns {boolean}
       * @private
       */
      _factIsValid(name, value) {
        if (name === null || name === void 0) {
          this.eventAdd("fact error", ERROR_FACT_NAME_ABSENT);
          return false;
        }
        name = name.toString();
        let nameTrimmed = name.trim();
        if (nameTrimmed.length === 0) {
          this.eventAdd("fact error", ERROR_FACT_NAME_EMPTY);
          return false;
        }
        if (regexpWhiteSpaces.test(name)) {
          this.eventAdd("fact error", ERROR_STUGNA_SPACE_IN_FACT_NAME + name);
          return false;
        }
        if (value === null || value === void 0) {
          this.eventAdd("fact error", ERROR_FACT_VALUE_ABSENT);
          return false;
        }
        return true;
      }
      /**
       * @param name {string|null|undefined}
       * @param value {string|number|boolean|null|undefined}
       * @param description {string|null|undefined}
       * @param toRegularize {boolean}
       */
      factAdd({ name, value, description }, isTrigger = true) {
        if (!this._factIsValid(name, value)) {
          return;
        }
        let subject = description;
        if (!subject) {
          subject = `${name}: ${value}`;
        }
        let factNew = new Fact(name, value, subject);
        let factOld = this._facts[name];
        if (factOld) {
          factOld.history.push(`init: ${subject}`);
          factNew.history = factOld.history;
        }
        this._facts[name] = factNew;
        this.eventAdd("fact add", null, subject);
        if (isTrigger) {
          this._order();
        }
      }
      /**
       * @param name
       * @returns {boolean}
       */
      factIsKnown(name) {
        return this._facts[name] !== void 0;
      }
      /**
       * @param name {string}
       * @returns {{name, value: *, history: (*|string[]|[string]|History), changed}|null}
       */
      factGet(name) {
        if (!this._facts[name]) {
          return null;
        }
        let value = this._facts[name].value;
        let history = this._facts[name].history;
        let changed = this._facts[name].changed;
        return { name, value, history, changed };
      }
      /**
       * @param name {string}
       * @returns {string[]}
       */
      factGetPredecessorsWanted(name) {
        let predecessors = [];
        for (let rule of this._rules) {
          if (rule.fact === name || rule.factElse === name) {
            for (let predecessor of rule.variables) {
              if (!predecessors.includes(predecessor)) {
                predecessors.push(predecessor);
              }
            }
          }
        }
        let childrenAll = [];
        for (let predecessor1 of predecessors) {
          let children = this.factGetPredecessorsWanted(predecessor1);
          childrenAll = childrenAll.concat(children);
        }
        for (let fact of childrenAll) {
          if (!predecessors.includes(fact)) {
            predecessors.push(fact);
          }
        }
        return predecessors;
      }
      /**
       * @param name {string}
       * @returns {string[]}
       */
      factGetPredecessorsUnknown(name) {
        let wanted = this.factGetPredecessorsWanted(name);
        let unknownWithRules = [];
        for (let fact of wanted) {
          if (this._facts[fact] === void 0) {
            unknownWithRules.push(fact);
          }
        }
        let unknownWithoutRules = [];
        for (let fact of unknownWithRules) {
          let noRuleForFact = true;
          for (let rule of this._rules) {
            if (rule.fact === fact || rule.factElse === fact) {
              noRuleForFact = false;
              break;
            }
          }
          if (noRuleForFact) {
            unknownWithoutRules.push(fact);
          }
        }
        return unknownWithoutRules;
      }
      /**
       * @param facts {Object[]}
       * @param isTrigger {boolean}
       */
      factsImport(facts, isTrigger = true) {
        let addedCount = 0;
        for (let fact of facts) {
          if (!this._factIsValid(fact.name, fact.value)) {
            continue;
          }
          this.factAdd(fact, false);
          addedCount++;
        }
        if (isTrigger && addedCount > 0) {
          this._order();
        }
      }
      /**
       * @returns {{name: string, value: (number|string), history: string[], changed: boolean}[]}
       */
      factsAllAsArray() {
        return Object.values(this._facts).map((fact) => {
          return {
            name: fact.name,
            value: fact.value,
            history: fact.history,
            changed: fact.changed
          };
        });
      }
      /**
       * @returns {object}
       */
      factsAllAsMap() {
        let facts = {};
        for (let name in this._facts) {
          facts[name] = this._facts[name].value;
        }
        return facts;
      }
      /**
       * @returns {boolean}
       */
      factsAreOrdered() {
        return this._factsAreOrdered;
      }
      /**
       *
       */
      factsClear() {
        this._facts = {};
        this.eventAdd("facts clear", "all facts are cleaned");
      }
      /**
       * @param condition {string}
       * @param factName {string}
       * @param factValue {string}
       * @param priority {number}
       * @param description {string}
       * @param factNameElse {string}
       * @param factValueElse {string}
       * @param final {number}
       * @param precondition {string}
       * @param missing {number|string|null}
       * @param isTrigger {boolean}
       */
      ruleAdd({
        condition,
        factName,
        factValue,
        priority,
        description,
        factNameElse,
        factValueElse,
        final,
        precondition,
        missing
      }, isTrigger = true) {
        let ruleError = Rule.validate(condition, factName, factValue, factNameElse, factValueElse);
        if (ruleError) {
          this.eventAdd("rule error", ruleError, description);
          return;
        }
        let rule = new Rule(condition, factName, factValue, priority, description, factNameElse, factValueElse, final, precondition, missing);
        ruleError = rule.getError();
        if (ruleError) {
          let subject = rule.description;
          this.eventAdd("rule error", ruleError, subject);
          return;
        }
        this._rules.push(rule);
        this._rules.sort((a, b) => {
          return a.priority - b.priority;
        });
        this.eventAdd("rule add", null, rule.description);
        if (isTrigger) {
          this._order();
        }
      }
      /**
       * @param rules {object[]}
       * @param isTrigger {boolean}
       */
      rulesImport(rules, isTrigger = true) {
        for (let rule of rules) {
          let ruleError = Rule.validate(rule.condition, rule.factName, rule.factValue, rule.factNameElse, rule.factValueElse);
          if (ruleError) {
            let subject = rule.description;
            if (!subject) {
              subject = Rule.createDescription(rule.condition, rule.factName, rule.factValue, rule.factNameElse, rule.factValueElse);
            }
            this.eventAdd("rule error", ruleError, subject);
            continue;
          }
          rule.priority = rule.priority ? rule.priority : 1;
          this.ruleAdd(rule, false);
        }
        if (isTrigger) {
          this._order();
        }
      }
      /**
       * @returns {object[]}
       */
      rulesAll() {
        let all = [];
        for (let rule of this._rules) {
          let item = {
            condition: rule.condition,
            factName: rule.fact,
            factValue: rule.value,
            factNameElse: rule.factElse,
            factValueElse: rule.valueElse,
            priority: rule.priority,
            description: rule.description,
            final: rule.final
          };
          for (let prop in item) {
            if (item[prop] === void 0) {
              delete item[prop];
            }
          }
          all.push(item);
        }
        return all;
      }
      /**
       *
       */
      rulesClear() {
        this._rules = [];
        this.eventAdd("rules clear", "all rules are cleaned");
      }
      /**
       * @param factName
       * @param factValue
       * @param eventName
       * @param ruleDescription
       * @private
       */
      _applyFact(factName, factValue, eventName, ruleDescription) {
        let factIsChanged = 0;
        let factNew = new Fact(factName, factValue, `${eventName}: ${ruleDescription}`);
        let factOld = this._facts[factName];
        if (!factOld || factOld.value !== factNew.value) {
          if (factOld) {
            factOld.history.push(`${eventName}: ${ruleDescription}`);
            factNew.history = factOld.history;
          }
          factNew.changed = true;
          this._facts[factName] = factNew;
          this.eventAdd(eventName, null, ruleDescription);
          factIsChanged = 1;
        }
        return factIsChanged;
      }
      /**
       * @param obj
       * @returns {any}
       * @private
       */
      _deepCopy(obj) {
        const str = JSON.stringify(obj);
        return JSON.parse(str);
      }
      /**
       * Fix missing facts by default values into temp map
       * @param factsExisting
       * @param factsMissing
       * @param defaultValue
       * @returns {*}
       * @private
       */
      _fixFactsMissing(factsExisting, factsMissing, defaultValue) {
        let factsTmp = this._deepCopy(factsExisting);
        for (let factName of factsMissing) {
          const fact = new Fact(factName, defaultValue, "");
          factsTmp[factName] = fact;
        }
        return factsTmp;
      }
      /**
       * Regularize all rules and facts
       */
      _order() {
        this._factsAreOrdered = false;
        let passCount = 1;
        let finalRuleHappened = false;
        while (passCount <= this._passCountMax) {
          let factsChanged = 0;
          for (let rule of this._rules) {
            let factsMissing = [];
            if (rule.hasPrecondition()) {
              if (!rule.checkWantedVariables(rule.prevariables, this._facts, factsMissing)) {
                if (this._toExplainMore) {
                  this.eventAdd("rule skip", `missing facts in precondition: ${factsMissing.join(", ")};`, rule.description);
                }
                continue;
              }
              if (!rule.check(this._facts, rule.precalc, true)) {
                if (this._toExplainMore) {
                  this.eventAdd("rule skip", `precondition not met`, rule.description);
                }
                continue;
              }
            }
            let factsAll = this._facts;
            factsMissing = [];
            if (!rule.checkWantedVariables(rule.variables, this._facts, factsMissing)) {
              if (rule.missing === void 0) {
                if (this._toExplainMore) {
                  this.eventAdd("rule skip", `missing fact in condition: ${factsMissing.join(", ")};`, rule.description);
                }
                continue;
              } else {
                factsAll = this._fixFactsMissing(this._facts, factsMissing, rule.missing);
              }
            }
            if (rule.check(factsAll, rule.calc, false)) {
              factsChanged += this._applyFact(rule.fact, rule.value, "rule ok", rule.description);
              finalRuleHappened = rule.final === 1 || rule.final === 3;
            } else {
              if (rule.hasElse()) {
                factsChanged += this._applyFact(rule.factElse, rule.valueElse, "rule else", rule.description);
                finalRuleHappened = rule.final === 2 || rule.final === 3;
              }
            }
            if (finalRuleHappened) {
              this.eventAdd("rule final", `Final rule happened`);
              break;
            }
          }
          this.eventAdd("rules passed", `Rules pass count is ${passCount}`);
          if (!factsChanged) {
            this._factsAreOrdered = true;
            break;
          }
          if (finalRuleHappened) {
            this._factsAreOrdered = true;
            break;
          }
          passCount++;
        }
        if (!this._factsAreOrdered && this._toSaveEvents) {
          this.eventAdd("rules error", ERROR_STUGNA_PERIODIC_RULES);
        }
      }
    };
    function ruleApply(condition, facts) {
      let result = false;
      let error = null;
      let factsMap = {};
      for (let fact of facts) {
        if (!fact.name)
          continue;
        factsMap[fact.name] = { value: fact.value };
      }
      let rule = new Rule(condition, "fact-name", "fact-value", 10, "description");
      if (rule.error) {
        error = rule.error;
      } else {
        let factsMissing = [];
        if (!rule.checkWantedVariables(rule.variables, factsMap, factsMissing)) {
          error = `missing facts: ${factsMissing.join(", ")}`;
          return [false, error];
        }
        result = rule.check(factsMap, rule.calc, false);
        if (rule.error) {
          error = rule.error;
        }
      }
      return [result, error];
    }
    module.exports = { StugnaES, ruleApply };
  }
});
export default require_stugna_es();
//# sourceMappingURL=stugna-es.js.map
